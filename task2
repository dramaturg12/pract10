Каждый вызов функции вызывает два предыдущих значения, тогда на первом этапе - 2 вызова, на втором - 4 вызова, на третьем 8 вызывов и т.д. 
Исходя из закономерности, сложность алгоритма равна 2^n. 

Пусть Т(fib(n))=O(2^n), тогда т.к. fib(n)= fib(n-1) + fib(n-2), то Т(fib(n))= Т(fib(n-1)) + Т(fib(n-2)) (не будем учитывать остальные участи кода, т.к. они имет сложность О(1)). Значит, по предположению О(2^n)=О(2^(n-1))+О(2^(n-2)). 

По методу математической индукции:
для n=1 равенство верно (О(1)=О(1))
Пусть верно для k-1: Т(fib(k-1))=O(2^(k-1)), тогда для к
Т(fib(k))= Т(fib(k-1)) + Т(fib(k-2))=О(2^(к-1))+О(2^(к-2))=О(0.5 * 2^k )+О(0.25 * 2^k)= O(0.75* 2^k)= O(2^k), ч.т.д.
